---
description: Introductory information about all Directus endpoints.
readTime: 5 min read
pageClass: page-reference
---

# Endpoints

> This page is an information-primer, full of stuff to keep in mind when using any Directus endpoint.

## Getting Started

There are two general types of collections in Directus.

[System Collections](/configuration/data-model/collections.md#system-collections) are generated by Directus. They are
required for the platform to function properly. System collections get their own custom endpoints. Any other collection
that exists in your project is simply called a [collection](/configuration/data-model/collections.md#collections). These
use the [items](/reference/items.md) endpoint.

For the most part, the endpoints themselves provide fundamental CRUD data management: _read one, read many, create one,
create many, etc._

In addition, the following tools are available as well:

[Query parameters](/reference/query.md) — Allow you customize _how the data is shaped and ordered_.\
[Filters](/reference/filter-rules.md) — Allow you to create conditional rules to customize _which data is selected_.\
[Flows](/configuration/flows.md) — Provide task automation, data transformation, custom computations, _and beyond_.\
[Extensions](/extensions/introduction.md) — If a feature is fundamentally missing, you can create an extension.

## Nested Relational Data

When you use the API from one collection, you can access data from relationally linked collections. To give two
examples, this allows you to retrieve the author details of your article included in the articles data, or fetch related
log entry points for your app's analytics data.

By default, Directus only retrieves the fields in your items that have been explicitly requested. Thus, nested
relational data can be retrieved by using [the `fields` parameter](/reference/query#fields) in REST or the SDK, or
simply with regular nested queries in GraphQL.

### A Note on GraphQL

Due to restrictions in GraphQL itself, it's impossible to properly scope/namespace system collections from the other
collections. In order to prevent any naming conflicts between user-created and system data, we've scoped the access of
the two into separate endpoints for user and system data respectively: `/graphql` and `/graphql/system`. Both endpoints
share the same underlying schema, so **nested relations will work as expected** regardless of whether they "cross over"
between user and system data. The only difference between the two endpoints are the root query and mutation fields
available.

### Creating / Updating / Deleting

Similarly to fetching, relational content can be modified deeply as well.

#### Many-to-One

Many-to-One relationships are fairly straightforward to manage relationally. You can simply submit the changes you want
as an object under the relational key in your collection. For example, if you wanted to create a new featured article on
your page, you could submit:

```json
{
	"featured_article": {
		"title": "This is my new article!"
	}
}
```

This will create a new record in the related collection, and save its primary key in the `featured_article` field for
this item. To update an existing item, simply provide the primary key with the updates, and Directus will treat it as an
update instead of a creation:

```json
{
	"featured_article": {
		"id": 15,
		"title": "This is an updated title for my article!"
	}
}
```

Seeing that the Many-to-One relationship stores the foreign key on the field itself, removing the item can be done by
nullifying the field:

```json
{
	"featured_article": null
}
```

#### One-to-Many (/ Many-to-Many)

One-to-Many, and therefore Many-to-Many and Many-to-Any, relationships can be updated in one of two ways:

**Basic**

The API will return one-to-many fields as an array of nested keys or items (based on the `fields` parameter). You can
use this same structure to select what the related items are:

```json
{
	"children": [2, 7, 149]
}
```

You can also provide an object instead of a primary key in order to create new items nested on the fly, or an object
with a primary key included to update an existing item:

```json
{
	"children": [
		2, // assign existing item 2 to be a child of the current item
		{
			"name": "A new nested item"
		},
		{
			"id": 149,
			"name": "Assign and update existing item 149"
		}
	]
}
```

To remove items from this relationship, simply omit them from the array:

```json
{
	"children": [2, 149]
}
```

This method of updating a one-to-many is very useful for smaller relational datasets.

**"Detailed"**

Alternatively, you can provide an object detailing the changes as follows:

```json
{
	"children": {
		"create": [{ "name": "A new nested item" }],
		"update": [{ "id": 149, "name": "A new nested item" }],
		"delete": [7]
	}
}
```

This is useful if you need to have more tightly control on staged changes, or when you're working with a big relational
dataset.

#### Many-to-Any (Union Types)

Many-to-Any fields work very similar to a "regular" many-to-many, with the exception that the related field can pull in
the fields from any of the related collections, for example:

```json
{
	"sections": [
		{
			"collection": "headings",
			"item": {
				/* headings fields */
			}
		},
		{
			"collection": "paragraphs",
			"item": {
				/* paragraphs fields */
			}
		}
	]
}
```

##### REST API

To scope the fields that are returned per collection type, you can use the `<field>:<scope>` syntax in the fields
parameter as follows:

```
GET /items/pages
	?fields[]=sections.item:headings.id
	&fields[]=sections.item:headings.title
	&fields[]=sections.item:paragraphs.body
	&fields[]=sections.item:paragraphs.background_color
```

##### GraphQL

In GraphQL, you can use nested fragments on the Union Type to select the fields:

```graphql
query {
	pages {
		sections {
			item {
				... on headings {
					id
					title
				}

				... on paragraphs {
					body
					background_color
				}
			}
		}
	}
}
```

::: tip Updating

Updating records in a many-to-any is identical to the other relationship types.

:::

## Error Codes

Below are the global error codes used within Directus, and what they mean.

::: warning Security

To prevent leaking which items exist, all actions for non-existing items return a `FORBIDDEN` error.

:::

| Error Code               | HTTP Status | Description                                                     |
| ------------------------ | ----------- | --------------------------------------------------------------- |
| `FAILED_VALIDATION`      | 400         | Validation for this particular item failed                      |
| `FORBIDDEN`              | 403         | You are not allowed to do the current action                    |
| `INVALID_TOKEN`          | 403         | Provided token is invalid                                       |
| `TOKEN_EXPIRED`          | 401         | Provided token is valid but has expired                         |
| `INVALID_CREDENTIALS`    | 401         | Username / password or access token is wrong                    |
| `INVALID_IP`             | 401         | Your IP address isn't allow-listed to be used with this user    |
| `INVALID_OTP`            | 401         | Wrong OTP was provided                                          |
| `INVALID_PAYLOAD`        | 400         | Provided payload is invalid                                     |
| `INVALID_QUERY`          | 400         | The requested query parameters can not be used                  |
| `UNSUPPORTED_MEDIA_TYPE` | 415         | Provided payload format or `Content-Type` header is unsupported |
| `REQUESTS_EXCEEDED`      | 429         | Hit the rate limit                                              |
| `ROUTE_NOT_FOUND`        | 404         | Endpoint does not exist                                         |
| `SERVICE_UNAVAILABLE`    | 503         | Could not use external service                                  |
| `UNPROCESSABLE_ENTITY`   | 422         | You tried doing something illegal                               |
